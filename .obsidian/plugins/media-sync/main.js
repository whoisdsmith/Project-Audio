/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MediaSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/modules.ts
var import_obsidian = require("obsidian");
var ALLOW_FILE_EXTENSIONS = ["png", "jpg", "jpeg", "gif"];
var START_MESSAGE = "Media Sync Start!!";
var PROCESS_MESSAGE = "Media Sync in Process!!";
var END_MESSAGE = "Media Sync End!!";
var ERROR_MESSAGE = "Error Occurred!! Please retry.";
var SKIP_URLS = [
  "https://twitter.com/intent/tweet",
  "https://twitter.com/share",
  "https://search.yahoo.co.jp/search"
];
var SaveDirectory = {
  Default: "_media-sync_resources",
  AttachmentFolderPath: "attachmentFolderPath",
  UserDefined: "resourceFolderName"
};
var DEFAULT_SETTINGS = {
  setting: {
    saveDirectory: SaveDirectory.Default,
    resourceFolderName: ""
  }
};
var getImageFilePrefix = () => {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  return `${year}${month}${day}T${hours}${minutes}${seconds}`;
};
var getRondomString = () => {
  return Math.floor(Math.random() * 1e5).toString().padStart(5, "0");
};
var getResorceFolderName = (vault, settings) => {
  let resourceFolderName;
  if (settings.setting.saveDirectory === SaveDirectory.AttachmentFolderPath) {
    resourceFolderName = vault.getConfig(
      SaveDirectory.AttachmentFolderPath
    );
  } else if (settings.setting.saveDirectory === SaveDirectory.UserDefined) {
    resourceFolderName = settings.setting.resourceFolderName;
  }
  if (!resourceFolderName) {
    resourceFolderName = SaveDirectory.Default;
  }
  return resourceFolderName;
};
var downloadImages = async (data, files, resorceFolderName, adapter, useCache = true) => {
  var _a, _b;
  if (!await adapter.exists(resorceFolderName)) {
    adapter.mkdir(resorceFolderName);
  }
  let totalCount;
  if (useCache) {
    totalCount = (_a = files.filter(
      (file) => {
        var _a2;
        return !((_a2 = data == null ? void 0 : data.files) == null ? void 0 : _a2.some((f) => f === file.name));
      }
    )) == null ? void 0 : _a.length;
  } else {
    totalCount = files.length;
  }
  let currentCount = 1;
  const errorUrls = [];
  for (const file of files) {
    const isSkip = (_b = data == null ? void 0 : data.files) == null ? void 0 : _b.some((f) => f === file.name);
    if (isSkip && useCache) {
      continue;
    }
    const currentNotice = new import_obsidian.Notice(
      `${PROCESS_MESSAGE} (${currentCount}/${totalCount})`,
      0
    );
    let fileContent = await adapter.read(file.path);
    const prefix = getImageFilePrefix();
    const currentFileFolderPath = `${resorceFolderName}/${prefix}`;
    if (!await adapter.exists(currentFileFolderPath)) {
      adapter.mkdir(currentFileFolderPath);
    }
    const urlMatches = fileContent.match(/https?:\/\/([\w!?/\-_=.&%;:,])+/g);
    if (urlMatches) {
      for (const urlMatche of urlMatches) {
        if (errorUrls.some((url) => url === urlMatche)) {
          continue;
        }
        const isTwitterIntentUrl = SKIP_URLS.some(
          (url) => urlMatche.startsWith(url)
        );
        if (isTwitterIntentUrl) {
          continue;
        }
        try {
          const response = await (0, import_obsidian.requestUrl)(urlMatche);
          const contentType = response.headers["content-type"];
          if (contentType.startsWith("image")) {
            const extension = contentType.split("/")[1];
            const isAllowExtension = ALLOW_FILE_EXTENSIONS.some(
              (ext) => extension.toLowerCase() === ext
            );
            let filePath = `${currentFileFolderPath}/${prefix}_${getRondomString()}`;
            if (isAllowExtension) {
              filePath = `${filePath}.${extension}`;
            } else {
              const realUrl = urlMatche.split("?")[0];
              const realExtention = ALLOW_FILE_EXTENSIONS.find(
                (ext) => realUrl.toLowerCase().endsWith(ext)
              );
              if (realExtention) {
                filePath = `${filePath}.${realExtention}`;
              } else {
                continue;
              }
            }
            fileContent = fileContent.replace(urlMatche, filePath);
            await adapter.writeBinary(filePath, response.arrayBuffer);
          }
        } catch (error) {
          console.log("access url error: " + urlMatche);
          console.log(error);
          errorUrls.push(urlMatche);
        }
      }
    }
    await adapter.write(file.path, fileContent);
    data.files.push(file.name);
    currentNotice.hide();
    currentCount++;
  }
};
var saveImageFiles = async (app, plugin, settings, selectFiles = [], useCache = true) => {
  const notices = [];
  notices.push(new import_obsidian.Notice(START_MESSAGE, 0));
  console.log(START_MESSAGE);
  notices.push(new import_obsidian.Notice(PROCESS_MESSAGE, 0));
  console.log(PROCESS_MESSAGE);
  let data;
  try {
    const dataJson = await plugin.loadData();
    data = JSON.parse(dataJson);
  } catch (error) {
    console.log("load data error");
    console.log(error);
  }
  if (!data) {
    data = {};
  }
  if (!data.files) {
    data.files = [];
  }
  let files = [];
  if (selectFiles.length > 0) {
    files = selectFiles;
  } else {
    files = app.vault.getMarkdownFiles();
  }
  const resorceFolderName = getResorceFolderName(app.vault, settings);
  await downloadImages(
    data,
    files,
    resorceFolderName,
    app.vault.adapter,
    useCache
  );
  try {
    const saveData = JSON.stringify({ ...data, ...settings });
    await plugin.saveData(saveData);
  } catch (error) {
    console.log("save data error");
    console.log(error);
    notices.push(new import_obsidian.Notice(ERROR_MESSAGE, 0));
  }
  notices.push(new import_obsidian.Notice(END_MESSAGE, 0));
  await new Promise((r) => setTimeout(r, 2e3));
  notices.forEach((notice) => notice.hide());
  console.log(END_MESSAGE);
};

// main.ts
var MediaSyncPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("leaf", "Media sync", (evt) => {
      saveImageFiles(this.app, this, this.settings);
    });
    this.addSettingTab(new MediaSyncSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        menu.addItem((item) => {
          item.setTitle("Media sync").onClick(async () => {
            if (file instanceof import_obsidian2.TFolder) {
              new import_obsidian2.Notice("Media sync does not support folders.");
              return;
            }
            saveImageFiles(
              this.app,
              this,
              this.settings,
              [file],
              false
            );
          });
        });
      })
    );
  }
  onunload() {
  }
  async loadSettings() {
    let data;
    try {
      data = await this.loadData();
    } catch (error) {
      console.log("load data error");
      console.log(error);
    }
    try {
      const loadData = JSON.parse(data);
      if (loadData.setting) {
        this.settings.setting = loadData.setting;
      } else {
        this.settings = DEFAULT_SETTINGS;
      }
    } catch (error) {
      this.settings = DEFAULT_SETTINGS;
    }
  }
};
var MediaSyncSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Folder to store images").setDesc("Specify a folder to store images.").addDropdown((dropdown) => {
      dropdown.addOption(SaveDirectory.Default, "Default").addOption(
        SaveDirectory.AttachmentFolderPath,
        "Obsidian attachment folder"
      ).addOption(SaveDirectory.UserDefined, "Custom folder").setValue(this.plugin.settings.setting.saveDirectory).onChange(async (value) => {
        this.plugin.settings.setting.saveDirectory = value;
        await this.saveSettings();
        if (value === SaveDirectory.UserDefined) {
          customFolderSetting.setDisabled(false);
        } else {
          customFolderSetting.setDisabled(true);
          const input = customFolderSetting.settingEl.querySelector("input");
          if (input) {
            input.value = "";
            this.plugin.settings.setting.resourceFolderName = "";
            await this.saveSettings();
          }
        }
      });
    });
    const customFolderSetting = new import_obsidian2.Setting(containerEl).setName("Custom folder name").setDesc("Specify folder name  where the images will be stored.").addText((text) => {
      text.setPlaceholder("Custom folder name").setValue(this.plugin.settings.setting.resourceFolderName).onChange(async (value) => {
        this.plugin.settings.setting.resourceFolderName = value;
        await this.saveSettings();
      }).setDisabled(true);
    });
  }
  async saveSettings() {
    try {
      let data;
      try {
        data = await this.plugin.loadData();
      } catch (error) {
        console.log("load data error");
        console.log(error);
      }
      let saveData;
      if (data) {
        saveData = JSON.stringify({
          ...JSON.parse(data),
          ...this.plugin.settings
        });
      } else {
        saveData = JSON.stringify({
          ...this.plugin.settings
        });
      }
      await this.plugin.saveData(saveData);
    } catch (error) {
      console.log("save data error");
      console.log(error);
    }
  }
};
