/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  PathFuzzy: () => PathFuzzy,
  default: () => Obsidian2BookClass
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  foldersToIgnore: [],
  filesToIgnore: [],
  tagsToIgnore: [],
  extensionsToIgnore: [],
  generateTOCs: true,
  includeEmptyFolders: false,
  sortingStrategy: "alphabetical" /* ALPHABETICAL */,
  lowGraneSortingStrategy: "file first" /* FILEFIRST */
};
var Obsidian2BookClass = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.ribbonButton = this.addRibbonIcon(
      "book",
      "Obsidian 2 Book: Generate a book from a specified folder",
      (evt) => {
        new PathFuzzy(this, generateBook).open();
      }
    );
    this.addCommand({
      id: "generate-vault-book",
      name: "Generate book from the entire vault",
      callback: () => {
        generateBook(this.app, this.settings);
      }
    });
    this.addCommand({
      id: "generate-book-from-folder",
      name: "Generate a book from a specified folder",
      callback: () => {
        new PathFuzzy(this, generateBook).open();
      }
    });
    this.addCommand({
      id: "remove-all-books-from-vault",
      name: "Remove all generated books from vault",
      callback: () => {
        new ConfirmModal(
          app,
          "Remove all books?",
          `You are about to delete every book you have created in you vault, procede?
					WARNING: All files containing the following comment: <!--book-ignore--> will be deleted`,
          () => removeAllBooks(app),
          () => {
          }
        ).open();
      }
    });
    this.addSettingTab(new Obsidian2BookSettingsPage(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
async function removeAllBooks(app2) {
  const { vault } = app2;
  const books = vault.getFiles();
  for (let i = 0; i < books.length; i++) {
    const file = books[i];
    const fileContent = await vault.read(file);
    if (isBook(fileContent)) {
      await vault.delete(file);
    }
  }
}
var fileList = [];
function isDocFile(file) {
  return file instanceof import_obsidian.TFile;
}
function isDocFolder(file) {
  return file instanceof import_obsidian.TFolder;
}
function isBook(fileContent) {
  return fileContent.includes("<!--book-ignore-->");
}
function checkTags(cache, tagsToIgnore) {
  if (cache == null)
    return false;
  const elabTags = tagsToIgnore.map((t) => {
    if (t[0] == "#")
      return t.slice(1).toLowerCase();
    return t.toLowerCase();
  });
  const frontmatter = cache.frontmatter;
  const found = cache.tags != null && cache.tags.some(
    (t) => elabTags.includes(t.tag.slice(1).toLocaleLowerCase())
  ) || frontmatter != void 0 && frontmatter.tag != null && elabTags.some((t) => frontmatter.tag.includes(t.toLowerCase()));
  return found;
}
async function checkFile(app2, file, settings) {
  const fileContent = await app2.vault.read(file);
  const isBookIgnore = isBook(fileContent);
  const cachedMetadata = app2.metadataCache.getFileCache(file);
  const isTagIgnore = checkTags(cachedMetadata, settings.tagsToIgnore);
  const isExtIgnore = settings.extensionsToIgnore.length == 0 ? false : settings.extensionsToIgnore.filter((x) => x.trim() != "").some((ext) => ("." + file.extension).includes(ext.trim()));
  const isFileIgnore = settings.filesToIgnore.length == 0 ? false : settings.filesToIgnore.filter((x) => x.trim() != "").some((f) => file.name.trim() == f.trim());
  return Promise.resolve(
    !isBookIgnore && !isTagIgnore && !isExtIgnore && !isFileIgnore
  );
}
function checkFolder(app2, file, settings) {
  const isFolderIgnore = settings.foldersToIgnore.length == 0 ? false : settings.foldersToIgnore.filter((x) => x.trim() != "").some((f) => file.name.trim() == f.trim());
  const isEmpty = settings.includeEmptyFolders ? false : file.children.length == 0;
  return !isFolderIgnore && !isEmpty;
}
function visitFolder(settings, fileStr, app2, onlyFolders = false, depth = 0) {
  if (fileStr instanceof import_obsidian.TFile && !onlyFolders) {
    const file = fileStr;
    fileList.push({
      type: "file",
      path: (depth > 0 ? "/" : "") + file.path,
      name: file.name,
      graphicName: file.basename,
      creationTime: file.stat.ctime,
      modificationTime: file.stat.mtime,
      depth,
      document: file
    });
  } else if (fileStr instanceof import_obsidian.TFolder) {
    const dir = fileStr;
    fileList.push({
      type: "folder",
      path: (depth > 0 ? "/" : "") + dir.path,
      name: dir.name,
      graphicName: dir.name,
      depth,
      document: dir
    });
    let allChild = dir.children;
    allChild = allChild.sort((a, b) => {
      if (isDocFolder(a) && isDocFile(b)) {
        if (settings.lowGraneSortingStrategy === "file first" /* FILEFIRST */)
          return 1;
        else
          return -1;
      }
      if (isDocFile(a) && isDocFolder(b)) {
        if (settings.lowGraneSortingStrategy === "file first" /* FILEFIRST */)
          return -1;
        else
          return 1;
      }
      if (isDocFolder(a) && isDocFolder(b)) {
        const dirA = a;
        const dirB = b;
        return dirA.name.localeCompare(dirB.name);
      }
      if (isDocFile(a) && isDocFile(b)) {
        const fileA = a;
        const fileB = b;
        switch (settings.sortingStrategy) {
          case "alphabetical" /* ALPHABETICAL */:
            return fileA.basename.localeCompare(fileB.basename);
          case "creation time" /* CREATION_TIME */:
            return fileA.stat.ctime - fileB.stat.ctime;
        }
      }
      return 0;
    });
    for (let i = 0; i < allChild.length; i++) {
      const child = allChild[i];
      if (child instanceof import_obsidian.TFolder && !checkFolder(app2, child, settings) || child instanceof import_obsidian.TFile && !checkFile(app2, child, settings))
        continue;
      visitFolder(settings, child, app2, onlyFolders, depth + 1);
    }
  }
}
async function getTableOfContent(currPath, currDepth, fileList2, settings) {
  const tocArray = [...fileList2].filter(
    (file) => file.depth === currDepth + 1 && file.path.includes(currPath)
  );
  let toc = "";
  for (let i = 0; i < tocArray.length; i++) {
    const file = tocArray[i];
    if (file.type === "folder") {
      const isFolderValid = await checkFolder(
        app,
        file.document,
        { ...settings }
      );
      if (isFolderValid)
        toc += `\u{1F4C2} [[#${file.graphicName}]]
`;
    } else {
      const isFileValid = await checkFile(
        app,
        file.document,
        settings
      );
      if (isFileValid)
        toc += `\u{1F4C4} [[#${file.graphicName}]]
`;
    }
  }
  return toc;
}
function getSpacer(isFullPage = false) {
  if (isFullPage) {
    return '<div style="page-break-after: always;"></div>';
  }
  return '<div style="height: 200px;"></div>';
}
var clamp = (number, min, max) => Math.max(min, Math.min(number, max));
async function generateBook(app2, settings, startingFolder = "/", depthOffset = 0) {
  const { vault } = app2;
  const generateTOCs = settings.generateTOCs;
  const files = vault.getAbstractFileByPath("/");
  if (files === null || !isDocFolder(files)) {
    console.error("Could not find folder: " + startingFolder);
    if (startingFolder === "/")
      new import_obsidian.Notice("Empty Vault");
    else
      new import_obsidian.Notice("Could not find folder: " + startingFolder);
    return Promise.resolve(false);
  }
  visitFolder(settings, files, app2);
  const documents = fileList.filter(
    (d) => d.path.startsWith(startingFolder)
  );
  fileList = [];
  let content = `
`;
  content += "\n<!--book-ignore-->\n<!--dont-delete-these-comments-->\n\n";
  for (let i = 0; i < documents.length; i++) {
    const file = documents[i];
    if (file.type === "folder") {
      const isFolderValid = checkFolder(app2, file.document, {
        ...settings
      });
      if (!isFolderValid)
        continue;
    }
    if (file.type === "file") {
      const isFileValid = await checkFile(app2, file.document, {
        ...settings
      });
      if (!isFileValid)
        continue;
    }
    const currToc = await getTableOfContent(
      file.path,
      file.depth,
      documents,
      { ...settings }
    );
    if (i == 0 && startingFolder == "/") {
      content += `# ${vault.getName()}

${generateTOCs ? currToc : ""}

---

${getSpacer(true)}

`;
    } else {
      const fileDepth = clamp(file.depth - depthOffset, 1, 6);
      const titleMD = new Array(fileDepth).fill("#").join("");
      if (file.type === "folder") {
        content += `${file.depth == 1 ? getSpacer(true) : "---"}

${titleMD} ${file.graphicName}

${generateTOCs ? currToc : ""}

---

`;
      } else {
        content += `

${titleMD} ${file.graphicName}

![[${file.path}|${file.name}]]

---

`;
      }
    }
  }
  try {
    const fileName = `${vault.getName() + (startingFolder == "/" ? "" : startingFolder.replace(/\s+|\\|\//g, "-"))}_book.md`;
    const fileExists = vault.getAbstractFileByPath(fileName);
    if (fileExists != null) {
      new ConfirmModal(
        app2,
        "Overwrite",
        `A file named ${fileName} already exists. Do you want to overwrite it?`,
        () => {
          vault.modify(fileExists, content).then(
            () => app2.workspace.getLeaf().openFile(fileExists)
          );
        },
        () => {
        }
      ).open();
    } else {
      const fileCreated = await vault.create(fileName, content);
      app2.workspace.getLeaf().openFile(fileCreated);
    }
  } catch (e) {
    new import_obsidian.Notice(e.toString());
  }
  return Promise.resolve(true);
}
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app2, title, content, confirmCallback, cancelCallback) {
    super(app2);
    this.titleEl.setText(title);
    this.contentEl.setText(content);
    this.confirmCallback = confirmCallback;
    this.cancelCallback = cancelCallback;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createDiv({ cls: "modal-button-container" }, (div) => {
      div.createEl(
        "button",
        { text: "Confirm", cls: "mod-cta" },
        (button) => {
          button.onClickEvent(() => {
            this.close();
            this.confirmCallback();
          });
        }
      );
      div.createEl("button", { text: "Cancel" }, (button) => {
        button.onClickEvent(() => {
          this.close();
          this.cancelCallback();
        });
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var PathFuzzy = class extends import_obsidian.FuzzySuggestModal {
  constructor(plugin, selectCallBack) {
    super(plugin.app);
    this.plugin = plugin;
    this.selectCallBack = selectCallBack;
  }
  getItems() {
    visitFolder(
      this.plugin.settings,
      this.app.vault.getRoot(),
      super.app,
      true
    );
    const files = [...fileList];
    fileList = [];
    return files;
  }
  getItemText(folder) {
    return folder.path;
  }
  onChooseItem(folder, evt) {
    new import_obsidian.Notice(`Selected ${folder.path}`);
    const depthOffset = folder.path.split("").filter((x) => x == "/").length - 1;
    this.selectCallBack(
      this.plugin.app,
      this.plugin.settings,
      folder.path,
      depthOffset
    );
  }
};
var Obsidian2BookSettingsPage = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Generate TOCs").setDesc("Generate Table of Contents for all directories").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.generateTOCs).onChange(async (value) => {
        this.plugin.settings.generateTOCs = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Include Empty folders").setDesc("Show titles of folders even if empty").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.includeEmptyFolders).onChange(async (value) => {
        this.plugin.settings.includeEmptyFolders = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Sorting strategy").setDesc("Sorting strategy for the book").addDropdown(
      (dropdown) => dropdown.addOption("alphabetical" /* ALPHABETICAL */, "Alphabetical").addOption("creation time" /* CREATION_TIME */, "Creation time").setValue(this.plugin.settings.sortingStrategy).onChange(async (value) => {
        this.plugin.settings.sortingStrategy = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Sorting order").setDesc("Sorting order for the book").addDropdown(
      (dropdown) => dropdown.addOption("file first" /* FILEFIRST */, "File First").addOption(
        "folder first" /* FOLDERFIRST */,
        "Folder First"
      ).setValue(this.plugin.settings.lowGraneSortingStrategy).onChange(async (value) => {
        this.plugin.settings.lowGraneSortingStrategy = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Add file to ignore").setDesc("Add file name to the list of file to be ignored").addButton(
      (button) => button.setButtonText("Add Element").onClick(async () => {
        this.plugin.settings.filesToIgnore.push("");
        await this.plugin.saveSettings();
        this.display();
      })
    );
    for (let i = 0; i < this.plugin.settings.filesToIgnore.length; i++) {
      const element = this.plugin.settings.filesToIgnore[i];
      new import_obsidian.Setting(containerEl).setName("File to ignore " + i).setDesc("Set file name to ignore").addText(
        (text) => text.setPlaceholder("Enter file name").setValue(element).onChange(async (value) => {
          this.plugin.settings.filesToIgnore[i] = value;
          await this.plugin.saveSettings();
        })
      ).addButton(
        (button) => button.setButtonText("-").onClick(async () => {
          this.plugin.settings.filesToIgnore.splice(i, 1);
          await this.plugin.saveSettings();
          this.display();
        })
      );
    }
    new import_obsidian.Setting(containerEl).setName("Add extension to ignore").setDesc("Add extension to the list of extensions to be ignored").addButton(
      (button) => button.setButtonText("Add Element").onClick(async () => {
        this.plugin.settings.extensionsToIgnore.push("");
        await this.plugin.saveSettings();
        this.display();
      })
    );
    for (let i = 0; i < this.plugin.settings.extensionsToIgnore.length; i++) {
      const element = this.plugin.settings.extensionsToIgnore[i];
      new import_obsidian.Setting(containerEl).setName("Extension to ignore " + i).setDesc("Set exntesion to ignore").addText(
        (text) => text.setPlaceholder("Enter exntesion").setValue(element).onChange(async (value) => {
          this.plugin.settings.extensionsToIgnore[i] = value;
          await this.plugin.saveSettings();
        })
      ).addButton(
        (button) => button.setButtonText("-").onClick(async () => {
          this.plugin.settings.extensionsToIgnore.splice(i, 1);
          await this.plugin.saveSettings();
          this.display();
        })
      );
    }
    new import_obsidian.Setting(containerEl).setName("Add folder to ignore").setDesc("Add folder name to the list of folder to be ignored").addButton(
      (button) => button.setButtonText("Add Element").onClick(async () => {
        this.plugin.settings.foldersToIgnore.push("");
        await this.plugin.saveSettings();
        this.display();
      })
    );
    for (let i = 0; i < this.plugin.settings.foldersToIgnore.length; i++) {
      const element = this.plugin.settings.foldersToIgnore[i];
      new import_obsidian.Setting(containerEl).setName("Folder to ignore " + i).setDesc("Set folder name to ignore").addText(
        (text) => text.setPlaceholder("Enter folder name").setValue(element).onChange(async (value) => {
          this.plugin.settings.foldersToIgnore[i] = value;
          await this.plugin.saveSettings();
        })
      ).addButton(
        (button) => button.setButtonText("-").onClick(async () => {
          this.plugin.settings.foldersToIgnore.splice(i, 1);
          await this.plugin.saveSettings();
          this.display();
        })
      );
    }
    new import_obsidian.Setting(containerEl).setName("Add tags to ignore").setDesc("Add tags name to the list of tags to be ignored").addButton(
      (button) => button.setButtonText("Add Element").onClick(async () => {
        this.plugin.settings.tagsToIgnore.push("");
        await this.plugin.saveSettings();
        this.display();
      })
    );
    for (let i = 0; i < this.plugin.settings.tagsToIgnore.length; i++) {
      const element = this.plugin.settings.tagsToIgnore[i];
      new import_obsidian.Setting(containerEl).setName("Tag to ignore " + i).setDesc("Set tag to ignore").addText(
        (text) => text.setPlaceholder("Enter tag").setValue(element).onChange(async (value) => {
          this.plugin.settings.tagsToIgnore[i] = value;
          await this.plugin.saveSettings();
        })
      ).addButton(
        (button) => button.setButtonText("-").onClick(async () => {
          this.plugin.settings.tagsToIgnore.splice(i, 1);
          await this.plugin.saveSettings();
          this.display();
        })
      );
    }
  }
};
